<?php

/**
 * Highlight a SVN diff for easier readibility
 */
class CodeDiffHighlighter {
	/** @var int chunk line count for the original file */
	protected $left = 0;
	/** @var int chunk line count for the changed file */
	protected $right = 0;
	/** @var int number of chunks */
	protected $chunk = 0;
	/** @var int line number inside patch */
	protected $lineNumber = 0;

	/**
	 * Main entry point. Given a diff text, highlight it
	 * and wrap it in a div
	 *
	 * @param string $text Text to highlight
	 * @return string
	 */
	public function render( $text ) {
		return '<table class="mw-codereview-diff">' .
			$this->splitLines( $text ) .
			"</table>\n";
	}

	/**
	 * Given a bunch of text, split it into individual
	 * lines, color them, then put it back into one big
	 * string
	 * @param string $text Text to split and highlight
	 * @return string
	 */
	public function splitLines( $text ) {
		return implode( "\n",
			array_map( [ $this, 'parseLine' ],
				explode( "\n", $text ) ) );
	}

	/**
	 * Internal dispatcher to a handler depending on line
	 * Handles lines beginning with '-' '+' '@' and ' '
	 * @param string $line Diff line to parse
	 * @return string HTML table line (with <tr></tr>)
	 */
	public function parseLine( $line ) {
		$this->lineNumber++;

		if ( $line === '' ) {
			// do not create bogus lines
			return '';
		}

		# Dispatch diff lines to the proper handler
		switch ( substr( $line, 0, 1 ) ) {
		case '-':
			if ( substr( $line, 0, 3 ) === '---' ) {
				return '';
			}
			$r = $this->handleLineDeletion( $line );
			break;
		case '+':
			if ( substr( $line, 0, 3 ) === '+++' ) {
				return '';
			}
			$r = $this->handleLineAddition( $line );
			break;
		case '@':
			$r = $this->handleChunkDelimiter( $line );
			break;
		case ' ':
			$r = $this->handleUnchanged( $line );
			break;

		# Patch lines that will be skipped:
		case '=':
			return '';

		# Remaining case should be the file name
		default:
			$r = $this->handleLineFile( $line );
		}

		# Return HTML generated by one of the handler
		return $r;
	}

	/**
	 * @param string $content
	 * @param string|null $class
	 * @return string
	 */
	public function formatLine( $content, $class = null ) {
		if ( $class === null ) {
			return Html::rawElement( 'tr', $this->getLineIdAttr(),
				Html::element( 'td', [ 'class' => 'linenumbers' ], $this->left ) .
					Html::element( 'td', [ 'class' => 'linenumbers' ], $this->right ) .
					Html::rawElement( 'td', [], Html::element( 'span', [], $content ) )
			);
		}

		# Skip line number when they do not apply
		$left = $right = ' '; // non-breaking space
		$inlineWrapEl = 'span';

		switch ( $class ) {
		case 'chunkdelimiter':
			$left = $right = '—'; // &mdash;
			break;
		case 'unchanged':
			$left  = $this->left;
			$right = $this->right;
			break;
		case 'del':
			$left  = $this->left;
			$inlineWrapEl = 'del';
			break;
		case 'ins':
			$right = $this->right;
			$inlineWrapEl = 'ins';
			break;

		default:
			# Rely on $left, $right initialization above
		}

		$classAttr = $class === null ? [] : [ 'class' => $class ];
		return Html::rawElement( 'tr', $this->getLineIdAttr(),
				Html::element( 'td', [ 'class' => 'linenumbers' ], $left )
				. Html::element( 'td', [ 'class' => 'linenumbers' ], $right )
				. Html::rawElement( 'td', $classAttr, Html::element( $inlineWrapEl, [], $content ) )
		);
	}

	public function handleLineDeletion( $line ) {
		$this->left++;
		return $this->formatLine( $line, 'del' );
	}

	public function handleLineAddition( $line ) {
		$this->right++;
		return $this->formatLine( $line, 'ins' );
	}

	public function handleChunkDelimiter( $line ) {
		$this->chunk++;

		list(
			$this->left,
			$leftChanged,  # unused
			$this->right,
			$rightChanged  # unused
		) = $this->parseChunkDelimiter( $line );

		return self::formatLine( $line, 'chunkdelimiter' );
	}

	public function handleUnchanged( $line ) {
		$this->left++;
		$this->right++;
		return $this->formatLine( $line, 'unchanged' );
	}

	public function handleLineFile( $line ) {
		$this->chunk = 0;
		return Html::rawElement( 'tr',
			array_merge( $this->getLineIdAttr(), [ 'class' => 'patchedfile' ] ),
			Html::Element( 'td', [ 'colspan' => 3 ], $line )
		);
	}

	public function getLineIdAttr() {
		return [ 'id' => $this->lineNumber ];
	}

	/**
	 * Turn a diff line into a properly formatted string suitable
	 * for output
	 * @param string $line Line from a diff
	 * @return string
	 */
	public function colorLine( $line ) {
		if ( $line == '' ) {
			return ''; // don't create bogus spans
		}
		list( $element, $attribs ) = $this->tagForLine( $line );
		return '<tr>' . Xml::element( $element, $attribs, $line ) . '</tr>';
	}

	/**
	 * Take a line of a diff and apply the appropriate stylings
	 * @param string $line Line to check
	 * @return array
	 */
	public function tagForLine( $line ) {
		static $default = [ 'td', [] ];
		static $tags = [
			'-' => [ 'td', [ 'class' => 'del' ] ],
			'+' => [ 'td', [ 'class' => 'ins' ] ],
			'@' => [ 'td', [ 'class' => 'meta' ] ],
			' ' => [ 'td', [] ],
		];
		$first = substr( $line, 0, 1 );
		if ( isset( $tags[$first] ) ) {
			return $tags[$first];
		} else {
			return $default;
		}
	}

	/**
	 * Parse unified diff change chunk header.
	 *
	 * The format represents two ranges for the left (prefixed with -) and right
	 * file (prefixed with +).
	 * The format looks like:
	 * @@ -l,s +l,s @@
	 *
	 * Where:
	 *  - l is the starting line number
	 *  - s is the number of lines the change hunk applies to
	 *
	 * 's', for the number of lines, is optional and default to 1.
	 * When omitted, the previous comma will be skipped as well. So all
	 * following lines are valid too:
	 *
	 * @@ -l,s +l @@
	 * @@ -l +l,s @@
	 * @@ -l +l @@
	 *
	 * NOTE: visibility is 'public' since the function covered by tests.
	 *
	 * @param string $chunkHeader a one line chunk as described above
	 * @throws Exception
	 * @return array with the four values above as an array
	 */
	public static function parseChunkDelimiter( $chunkHeader ) {
		$chunkHeader = rtrim( $chunkHeader );

		# regex snippet to capture a number
		$n = "(\d+)";
		$s = "(?:,(\d+))";
		$matches = preg_match( "/^@@ -$n$s \+$n$s @@$/", $chunkHeader, $m );
		if ( $matches === 1 ) {
			array_shift( $m );
			return $m;
		}

		$s_default_value = 1;

		$matches = preg_match( "/^@@ -$n$s \+$n @@$/", $chunkHeader, $m );
		if ( $matches === 1 ) {
			return [ $m[1], $m[2], $m[3], $s_default_value ];
		}

		$matches = preg_match( "/^@@ -$n \+$n$s @@$/", $chunkHeader, $m );
		if ( $matches === 1 ) {
			return [ $m[1], $s_default_value, $m[2], $m[3] ];
		}

		$matches = preg_match( "/^@@ -$n \+$n @@$/", $chunkHeader, $m );
		if ( $matches === 1 ) {
			return [ $m[1], $s_default_value, $m[2], $s_default_value ];
		}

		# We really really should have matched something!
		throw new Exception(
			__METHOD__ . " given an invalid chunk header: '$chunkHeader'\n"
		);
	}
}
